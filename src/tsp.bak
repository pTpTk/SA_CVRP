#include "TSP.h"
#include <vector>

TSP::TSP(Params* p, V<int>& vi, V<double>& vd)
: params(p), Coeff(vd), r_in(vi)
{}

void TSP::test()
{
    spin[ 0] = V<bool>{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    spin[ 1] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    spin[ 2] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    spin[ 3] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 4] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 5] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    spin[ 6] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 7] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    spin[ 8] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 9] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[10] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[11] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    spin[12] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[13] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[14] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[15] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    spin[16] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[17] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[18] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    spin[19] = V<bool>{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0};
    qubo_ene();
    spin[ 0] = V<bool>{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    spin[ 1] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    spin[ 2] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    spin[ 3] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 4] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 5] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    spin[ 6] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 7] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    spin[ 8] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 9] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[10] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[11] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    spin[12] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[13] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[14] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[15] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    spin[16] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[17] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[18] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    spin[19] = V<bool>{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0};
    qubo_ene();
    spin[ 0] = V<bool>{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    spin[ 1] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    spin[ 2] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0};
    spin[ 3] = V<bool>{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 4] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 5] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    spin[ 6] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 7] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    spin[ 8] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[ 9] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[10] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[11] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    spin[12] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[13] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[14] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[15] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
    spin[16] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[17] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    spin[18] = V<bool>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0};
    spin[19] = V<bool>{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0};
    qubo_ene();
    std::cout << Distance[0][19]<<std::endl;
    std::cout << Distance[0][3]<<std::endl;
    std::cout << Distance[3][19]<<std::endl;
}

void TSP::work(int iter=8000)
{
    sweeps = iter;
    scale = sweeps > 1 ? (beta1 - beta0) / (sweeps - 1) : 0.00;
    init(1);
    test();
    //SA();
    //for(int i = 0; i < r_in.size(); i++){
    //    init(i);
    //    SA();
    //}
}

void TSP::fill(int i){
    V<int> n_i(params->correlatedVertices[i]);
    for(int n : nodelist){
        auto pos = std::find(n_i.begin(), n_i.end(), n);
        if(pos != n_i.end())
            n_i.erase(pos);
    }

    nodelist.insert(nodelist.end(), n_i.begin(), n_i.end());
    printf("nodelist.size() = %d\n", nodelist.size());
}

/* Last item of the matrix is the depot node. Since the route has to start from 
 * the depot, it's implied in the assignment. The depot node is to satisfy other
 * properties of the solution. */

void TSP::init(int i)
{
    nodelist = r_in;
    fill(i);
    for(auto& n : nodelist){
        std::cout << n << ' ';
    }
    std::cout << std::endl;
    
    // Dist[i][j] = dist(i -> j)
    graph_size_i = nodelist.size() + 1;
    graph_size_j = nodelist.size();

    Distance.clear();
    Demand.clear();

    Distance.resize(graph_size_i); // final row for depot
    Demand.resize(graph_size_i);
   
    for(auto& d : Distance)
        d.resize(graph_size_i);    // final column for depot

    for(int j = 0; j < nodelist.size(); j++){
        auto nj = nodelist[j];
        Distance[j][j] = 999;
        for(int k = j+1; k < nodelist.size(); k++){
            auto nk = nodelist[k];
            Distance[j][k] = Distance[k][j] = params->timeCost[nj][nk];
        }
        //Distance[j].back() = params->timeCost[nj][0];
        Distance[j].back() = 500;
        Demand[j] = params->cli[j].demand;
    }

    auto& DepotDist = Distance.back();
    DepotDist = std::vector<double>(graph_size_i, 999);
    DepotDist.back() = 0;

    for(int j = 0; j < graph_size_i; j++){
        for(int k = 0; k < graph_size_i; k++){
            Distance[j][k] -= 500;
        }
    }


    Demand.back() = 0;
    
    spin.resize(graph_size_i);

    srand(time(NULL));

    for(auto& s : spin){
        s.resize(graph_size_j);
        for(int j = 0; j < graph_size_j; j++)
            s[j] = rand() % 2;
    }

    spin[graph_size_i-1][0] = 0;
    beta = beta0;
}

void TSP::SA()
{
    double d, ene;

    ene = qubo_ene();
    //return;

    for(int iter = 0; iter < sweeps; iter++){
        std::cout << iter << std::endl;
        for(int i = 0; i < graph_size_i; i++){
            std::cout << i << std::endl;
            for(int j = 0; j < graph_size_j; j++){
                d = diff(i, j);
                if(accept(d)){
                    spin[i][j] = (spin[i][j]+1)%2;
                    ene += d;
                    assert(ene == qubo_ene());
                    std::cout << "spin flipped" << std::endl;
                    
                    for(int i = 0; i < graph_size_i; i++){
                        for(int j = 0; j < graph_size_j; j++){
                            std::cout << spin[i][j] << ' ';
                        }
                        std::cout << std::endl;
                    }
                }
            }
        }
        beta -= scale;
    }

    assert(ene == qubo_ene());
    update_out();
}

double TSP::qubo_ene(){
    double ene(0);
    int ene_row(0), ene_col(0);
    double ene_dis(0), ene_dem(0);

    for(int i = 0; i < graph_size_i; i++){
        for(int j = 0; j < graph_size_j; j++){
            for(int k = 0; k < graph_size_i; k++){
                if(i != k)
                ene_col += spin[i][j] * spin[k][j];
            }
            ene_col -= spin[i][j];
        }
    }
    ene += Coeff[0] * ene_col;
    printf("ene_col = %.1f\n", Coeff[0] * ene_col);

    for(int i = 0; i < graph_size_i-1; i++){
        for(int j = 0; j < graph_size_j; j++){
            for(int k = 0; k < graph_size_j; k++){
                if(j != k)
                ene_row += spin[i][j] * spin[i][k];
            }
        }
    }
    ene += Coeff[1] * ene_row;
    printf("ene_row = %.1f\n", Coeff[1] * ene_row);

    for(int i = 0; i < graph_size_i; i++){
        //ene_dis += spin[i][0]     * Distance[i].back();
        //ene_dis += spin[i].back() * Distance[i].back();
        if(i != graph_size_i-1){
            ene_dis += spin[i][0]     * params->timeCost[nodelist[i]][0];
            ene_dis += spin[i].back() * params->timeCost[nodelist[i]][0];
        }
        for(int k = 0; k < graph_size_i; k++){
            for(int j = 0; j < graph_size_j-1; j++){
                ene_dis += spin[i][j] * spin[k][j+1] * Distance[i][k];
                if(spin[i][j] * spin[k][j+1] == 1)
                    printf("Distance[%d][%d] = %.1f\n", i, k, Distance[i][k]);
            }
        }
    }
    ene_dis += spin[graph_size_i-1][0] * 9999;
    ene += Coeff[2] * ene_dis;
    printf("ene_dis = %.1f\n", Coeff[2] * ene_dis);

    for(int i = 0; i < graph_size_i; i++){
        for(int j = 0; j < graph_size_j; j++){
            ene_dem += Demand[i] * Demand[i] * spin[i][j];
            ene_dem -= Demand[i] * 2 * params->vehicleCapacity * spin[i][j];
            for(int k = 0; k < graph_size_i; k++){
                for(int l = 0; l < graph_size_j; l++){
                    if(i != k || j != l)
                    ene_dem += Demand[i] * Demand[k] * spin[i][j] * spin[k][l];
                }
            }
        }
    }
    ene += Coeff[3] * ene_dem;
    printf("ene_dem = %.1f\n", Coeff[2] * ene_dem);
    printf("qubo_ene = %f\n", ene);
    return ene;
}

double TSP::diff(int i, int j)
{
    printf("i = %d, j = %d\n", i, j);
    int diff_row(0), diff_col(0);
    double diff_dis(0), diff_dem, diff;
    double dem_i, dem_k;

    // ensure only one 1 each column (each round has only 1 destination)
    for(int k = 0; k < graph_size_i; k++)
        if(k != i)
            diff_col += spin[k][j];
    diff_col = 2 * diff_col - 1;
    //printf("\ndiff_col = %d\n", diff_col);

    // ensure no more than one 1 each row (go to a client no more than once)
    if(i != graph_size_i-1){
        for(int k = 0; k < graph_size_j; k++)
            if(k != j)
                diff_row += spin[i][k];
        diff_row *= 2;
    }
    //printf("diff_row = %d\n", diff_row);

    // distance constraint
    if(i != graph_size_i-1 && (j == 0 || j == graph_size_j-1))
        diff_dis += params->timeCost[0][nodelist[i]];
    if(i == graph_size_i-1 && j == 0)
        diff_dis += 9999;
    for(int k = 0; k < graph_size_i; k++){
        diff_dis += (j == 0)              ? 0 : Distance[k][i] * spin[k][j-1];
        diff_dis += (j == graph_size_j-1) ? 0 : Distance[i][k] * spin[k][j+1];
    }
    printf("diff_dis = %f\n", diff_dis * Coeff[2]);

    // capacity constraint
    dem_i = Demand[i];
    diff_dem = dem_i * dem_i - 2 * params->vehicleCapacity * dem_i;
    for(int k = 0; k < graph_size_i; k++){
        dem_k = Demand[k];
        for(int l = 0; l < graph_size_j; l++){
            if(k != i || l != j)
            diff_dem += 2 * dem_i * dem_k * spin[k][l];
        }
    }
    //printf("diff_dem = %f\n", diff_dem * Coeff[3]);

    diff = Coeff[0] * diff_col + Coeff[1] * diff_row + Coeff[2] * diff_dis + Coeff[3] * diff_dem;
    //printf("diff = %f\n", diff);
                    
    return (spin[i][j]) ? -diff : diff;
}

void TSP::update_out()
{
    V<int> r;
    int tmp(0);

    for(int i = 0; i < graph_size_i; i++){
        for(int j = 0; j < graph_size_j; j++){
            std::cout << spin[i][j] << ' ';
        }
        if(i < graph_size_j)
            std::cout << "\t" << nodelist[i];
        else
            std::cout << "\t0";
        std::cout << std::endl;
    }

    for(int i = 0; i < graph_size_j; i++){
        tmp = 0;
        for(int j = 0; j < graph_size_i; j++){
            if(spin[j][i] == 1){
                r.emplace_back(nodelist[j]);
                tmp++;
            }
        }
        if(tmp != 1){
            printf("SA failed\n");
            //return;
        }
    }

    r_out.emplace_back(r);
}

bool TSP::accept(double d)
{
    return (d < 0) || (dis(gen) < exp(beta * d));
}

